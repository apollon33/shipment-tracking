{"version":3,"sources":["../../src/api/index.js"],"names":["config","db","api","use","get","req","res","status","json","version","text","query","trackingNumber","error","details","collection","findOne","then","item","catch","console","log","err","post","body","shipmentType","sourceAdress","targetAdress","data","shipmentObj","findTrackingNumber","insertOne","result","ops","length","send","put","trackingItem","updatedStates","states","slice","updatedState","Object","assign","state","scanned","notice","time","Date","updatedItem","findOneAndUpdate","$set"],"mappings":";;;;;;AAAA;;AACA;;AACA;;;;AACA;;;;;;kBAGe,gBAAoB;AAAA,QAAjBA,MAAiB,QAAjBA,MAAiB;AAAA,QAATC,EAAS,QAATA,EAAS;;AAClC,QAAIC,MAAM,sBAAV;;AAEA;AACAA,QAAIC,GAAJ,CAAQ,SAAR,EAAmB,sBAAO,EAAEH,cAAF,EAAUC,MAAV,EAAP,CAAnB;;AAEA;AACAC,QAAIE,GAAJ,CAAQ,GAAR,EAAa,UAACC,GAAD,EAAMC,GAAN,EAAc;AACpBA,YAAIC,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEC,yBAAF,EAAWC,MAAM,MAAjB,EAArB;AACN,KAFD;;AAIA;AACAR,QAAIE,GAAJ,CAAQ,WAAR,EAAqB,UAACC,GAAD,EAAMC,GAAN,EAAc;AAClC;;AAEM;AACA,YAAI,CAAC,qCAAsBD,IAAIM,KAAJ,CAAUC,cAAhC,CAAL,EAAqD;AACjDN,gBAAIC,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEK,uCAAF,EAArB;AACA;AACH;;AAED,YAAMC,UAAU,EAAE,kBAAkBT,IAAIM,KAAJ,CAAUC,cAA9B,EAAhB;AACAX,WAAGc,UAAH,CAAc,UAAd,EAA0BC,OAA1B,CAAkCF,OAAlC,EACKG,IADL,CACU,gBAAQ;AACV;AACA,gBAAIT,OAAQU,IAAD,GAASA,IAAT,GAAgB,EAAEL,oDAAkDR,IAAIM,KAAJ,CAAUC,cAA9D,EAA3B;AACAN,gBAAIC,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBA,IAArB;AACH,SALL,EAKOW,KALP,CAKa,eAAO;AACZC,oBAAQC,GAAR,CAAY,KAAZ,EAAmBC,GAAnB;AACAhB,gBAAIE,IAAJ,CAAS,EAAEK,sDAAoDR,IAAIM,KAAJ,CAAUC,cAA9D,SAAgFU,GAAlF,EAAT;AACH,SARL;AASN,KAnBD;;AAqBA;AACApB,QAAIqB,IAAJ,CAAS,WAAT,EAAsB,UAAClB,GAAD,EAAMC,GAAN,EAAc;AACnC;AACM,YAAI,CAACD,GAAD,IAAQ,CAACA,IAAImB,IAAJ,CAASC,YAAlB,IAAkC,CAACpB,IAAImB,IAAJ,CAASE,YAA5C,IAA4D,CAACrB,IAAImB,IAAJ,CAASG,YAA1E,EAAwF;AACvFP,oBAAQC,GAAR,CAAY,mBAAZ;AACGf,gBAAIE,IAAJ,CAAS,EAAEK,+GAAF,EAAT;AAEH;AACA;;AAED,YAAMe,OAAOvB,IAAImB,IAAjB;AACA;;;;;;AAMN,YAAIK,oBAAJ;AAAA,YAAiBf,gBAAjB;AACM,YAAIgB,qBAAqB,SAArBA,kBAAqB,GAAM;AAC3BD,0BAAc,wBAA6BD,IAA7B,CAAd;AACAd,sBAAU,EAAEF,gBAAgBiB,YAAYjB,cAA9B,EAAV;AACAX,eAAGc,UAAH,CAAc,UAAd,EAA0BC,OAA1B,CAAkCF,OAAlC,EACKG,IADL,CACU,gBAAQ;AACV;;;AAGAC,yBAAS,IAAT,IAAiBY,oBAAjB;;AAEA,uBAAO7B,GAAGc,UAAH,CAAc,UAAd,EAA0BgB,SAA1B,CAAoCF,WAApC,CAAP;AACH,aARL,EASKV,KATL,CASW;AAAA,uBAAOC,QAAQC,GAAR,CAAY,EAAER,mDAAiDS,GAAnD,EAAZ,CAAP;AAAA,aATX,EAUKL,IAVL,CAUU,kBAAU;AACZ;AACAG,wBAAQC,GAAR,CAAY,YAAZ,EAA0BW,UAAUA,OAAOC,GAA3C;AACAD,0BAAUA,OAAOC,GAAjB,IAAwBD,OAAOC,GAAP,CAAWC,MAAnC,IACG5B,IAAIE,IAAJ,CAAS,EAAEoB,MAAMI,OAAOC,GAAP,CAAW,CAAX,CAAR,EAAuBrB,gBAAgBiB,YAAYjB,cAAnD,EAAT,CADH;AAEH,aAfL,EAgBKO,KAhBL,CAgBW;AAAA,uBAAOb,IAAI6B,IAAJ,CAAS,EAAEtB,mDAAiDS,GAAnD,EAAT,CAAP;AAAA,aAhBX;AAiBH,SApBD;AAqBAQ;AAEN,KAxCD;;AA0CA;AACA5B,QAAIkC,GAAJ,CAAQ,WAAR,EAAqB,UAAC/B,GAAD,EAAMC,GAAN,EAAc;AAC5B,YAAMQ,UAAU,EAAE,kBAAkBT,IAAImB,IAAJ,CAASZ,cAA7B,EAAhB,CAD4B,CACmC;AAC/D,YAAMyB,eAAehC,IAAImB,IAAzB;;AAEAvB,WAAGc,UAAH,CAAc,UAAd,EAA0BC,OAA1B,CAAkCF,OAAlC,EACKG,IADL,CACU,gBAAQ;AACV;AACA,gBAAIqB,gBAAgBpB,KAAKqB,MAAL,CAAYC,KAAZ,EAApB;AACA,gBAAIC,eAAeC,OAAOC,MAAP,CAAc,EAAd,EAAkBL,cAAcD,aAAaO,KAA3B,CAAlB,CAAnB;AACAH,yBAAaI,OAAb,GAAuB,IAAvB;AACAJ,yBAAaK,MAAb,GAAsBT,aAAaS,MAAnC;AACAL,yBAAaM,IAAb,GAAoB,IAAIC,IAAJ,EAApB;AACAV,0BAAcD,aAAaO,KAA3B,IAAoCH,YAApC;AACA,gBAAIQ,cAAcP,OAAOC,MAAP,CAAc,EAAd,EAAkBzB,IAAlB,EAAwB,EAAEqB,QAAQD,aAAV,EAAxB,CAAlB;;AAEA;AACA,mBAAOrC,GAAGc,UAAH,CAAc,UAAd,EAA0BmC,gBAA1B,CAA2CpC,OAA3C,EAAoD,EAACqC,MAAM,EAACZ,QAAQU,YAAYV,MAArB,EAAP,EAApD,CAAP;AACH,SAbL,EAcKtB,IAdL,CAcU,gBAAQ;AACV,gBAAIT,OAAQU,IAAD,GAASA,IAAT,GAAgB,EAAEL,oDAAkDwB,aAAazB,cAAjE,EAA3B;AACAN,gBAAIC,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBA,IAArB;AACH,SAjBL,EAkBKW,KAlBL,CAkBW,eAAO;AACVC,oBAAQC,GAAR,CAAY,KAAZ,EAAmBC,GAAnB;AACAhB,gBAAIC,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEK,OAAUwB,aAAazB,cAAvB,oBAAoDU,GAAtD,EAArB;AACH,SArBL;AAsBI;AAEV,KA5BD;;AA8BA,WAAOpB,GAAP;AACA,C","file":"index.js","sourcesContent":["import { version } from '../../package.json';\r\nimport { Router } from 'express';\r\nimport facets from './facets';\r\nimport generateUniqueTrackingNumber, { isValidTrackingNumber } from './tracking'\r\n\r\n\r\nexport default ({ config, db }) => {\r\n\tlet api = Router();\r\n\r\n\t// mount the facets resource\r\n\tapi.use('/facets', facets({ config, db }));\r\n\r\n\t// perhaps expose some API metadata at the root\r\n\tapi.get('/', (req, res) => {\r\n        res.status(200).json({ version, text: 'some' });\r\n\t});\r\n\r\n\t// get a tracking object with states etc. by tracking number\r\n\tapi.get('/tracking', (req, res) => {\r\n\t\t// console.log('req.query: ', req.query);\r\n\r\n        /* opt out if the tracking number is not valid because of checksum */\r\n        if (!isValidTrackingNumber(req.query.trackingNumber)){\r\n            res.status(200).json({ error: `The tracking number is invalid`});\r\n            return\r\n        }\r\n\r\n        const details = { 'trackingNumber': req.query.trackingNumber };\r\n        db.collection('shipment').findOne(details)\r\n            .then(item => {\r\n                /* if item exists, send back the item with its states, otherwise send error message */\r\n                let json = (item) ? item : { error: `Could not find tracking information for ${req.query.trackingNumber}` }\r\n                res.status(200).json(json);\r\n            }).catch(err => {\r\n                console.log('err', err)\r\n                res.json({ error: `An error has occurred while searching for ${req.query.trackingNumber} ${err}`});\r\n            });\r\n\t}); \r\n\r\n\t// create a new tracking number with mocked states data\r\n\tapi.post('/tracking', (req, res) => {\r\n\t\t// console.log('req, res', req.body)\r\n        if (!req || !req.body.shipmentType || !req.body.sourceAdress || !req.body.targetAdress) {\r\n        \tconsole.log(\"something missing\")\r\n            res.json({ error: `A shipment has to contain a shipmentType, \r\n\t\t\t\t        a sourceAdress and a targetAdress property`});\r\n        \treturn;\r\n        }\r\n\r\n        const data = req.body;\r\n        /* in order to garantue a really unique tracking number in the database, we search for\r\n         * the generated tracking number within the db and generate a new tracking number\r\n         * until there is no collision anymore. This approach assumes that the\r\n         * database is cleared or archived after a fixed period of time to continually allow\r\n         * produce really unique tracking numbers and not run out of available slots.\r\n         */\r\n\t\tlet shipmentObj, details;\r\n        let findTrackingNumber = () => {\r\n            shipmentObj = generateUniqueTrackingNumber(data)\r\n            details = { trackingNumber: shipmentObj.trackingNumber }\r\n            db.collection('shipment').findOne(details)\r\n                .then(item => {\r\n                    /* if an item with this tracking number was found, it is found in item\r\n                     * otherwise its null and we generate a new tracking number recursively\r\n                     */\r\n                    item !== null && findTrackingNumber()\r\n\r\n                    return db.collection('shipment').insertOne(shipmentObj)\r\n                })\r\n                .catch(err => console.log({ error: `An error has occurred while inserting: ${err}`  }))\r\n                .then(result => {\r\n                    /* resolve of db.collection('shipment').insertOne(shipmentObj) */\r\n                    console.log('result.ops', result && result.ops)\r\n                    result && result.ops && result.ops.length\r\n                    && res.json({ data: result.ops[0], trackingNumber: shipmentObj.trackingNumber });\r\n                })\r\n                .catch(err => res.send({ error: `An error has occurred while inserting: ${err}`  }))\r\n        }\r\n        findTrackingNumber();\r\n\r\n\t});\r\n\r\n\t/* update existing shipment by tracking number, notice and state to update */\r\n\tapi.put('/tracking', (req, res) => {\r\n        const details = { 'trackingNumber': req.body.trackingNumber }; /* db search argument */\r\n        const trackingItem = req.body;\r\n\r\n        db.collection('shipment').findOne(details)\r\n            .then(item => {\r\n                /* set scanned to true of according state and set a notice message */\r\n                let updatedStates = item.states.slice();\r\n                let updatedState = Object.assign({}, updatedStates[trackingItem.state]);\r\n                updatedState.scanned = true;\r\n                updatedState.notice = trackingItem.notice;\r\n                updatedState.time = new Date();\r\n                updatedStates[trackingItem.state] = updatedState;\r\n                let updatedItem = Object.assign({}, item, { states: updatedStates });\r\n\r\n                /* update in the db*/\r\n                return db.collection('shipment').findOneAndUpdate(details, {$set: {states: updatedItem.states}})\r\n            })\r\n            .then(item => {\r\n                let json = (item) ? item : { error: `Could not find tracking information for ${trackingItem.trackingNumber}` }\r\n                res.status(200).json(json);\r\n            })\r\n            .catch(err => {\r\n                console.log('err', err)\r\n                res.status(404).json({ error: `${trackingItem.trackingNumber} not found. ${err}`});\r\n            });\r\n            /* perfectly chain it to avoid callback hell */\r\n\r\n\t});\r\n\r\n\treturn api;\r\n}\r\n"]}